# Project Cursor Rules

## Data Quality Standards
- Every piece of retrieved data MUST include a confidence score (0-100%)
- Document data sources and retrieval timestamps
- Indicate any assumptions or limitations in the data

## Verification Protocol
- Perform validation checks during task execution
- After completing the task AND providing the summary, conduct a FINAL comprehensive error check on all data
- The final verification is supplementary to—not a replacement for—ongoing validation
- Report any discrepancies found in the final check

## Code Hygiene
- Do NOT create README files unless explicitly requested
- Clean up all temporary files, scripts, and helper files after task completion
- Remove unused imports, commented code, and debug statements

## Project Organization
- Create logical directory structures with appropriate subdirectories
- Group related functionality together
- Use clear, descriptive naming conventions for directories and files
- Maintain separation of concerns (data, scripts, outputs, configs, etc.)

## Documentation Organization - MANDATORY

### Structure Requirements:
- **NEVER create documentation files in the project root directory**
- **ALWAYS organize documentation in `docs/` with proper subdirectories**
- **Root directory should ONLY contain:**
  - `README.md` (project overview and quick links to docs/)
  - Essential config files (`docker-compose.yml`, `Dockerfile`, `package.json`, etc.)
  - Executable scripts (`start.sh`, `setup.sh`, etc.)
  - `.gitignore`, `.cursorrules`, license files

### Standard Documentation Structure:

```
docs/
├── setup/              # Installation, deployment, configuration
│   ├── QUICK_START.md
│   ├── INSTALLATION.md
│   ├── DEPLOYMENT.md
│   └── CONFIGURATION.md
├── development/        # Developer guides, workflows, standards
│   ├── CONTRIBUTING.md
│   ├── ARCHITECTURE.md
│   ├── TESTING_STRATEGY.md
│   └── CODE_STYLE.md
├── features/           # Feature-specific documentation (hierarchical)
│   ├── authentication/
│   │   ├── overview.md
│   │   ├── oauth-setup.md
│   │   └── session-management.md
│   ├── data-processing/
│   │   ├── scraping/
│   │   │   ├── image-scraping.md
│   │   │   └── metadata-extraction.md
│   │   └── validation/
│   │       └── data-validation-rules.md
│   └── user-interface/
│       ├── dashboard.md
│       └── forms.md
├── guides/             # General how-to guides (non-feature-specific)
│   ├── integration-guides.md
│   ├── troubleshooting.md
│   └── best-practices.md
├── api/                # API documentation (if applicable)
│   ├── endpoints.md
│   └── authentication.md
├── status/             # Project status, completion reports, changelogs
│   ├── CHANGELOG.md
│   ├── completion-reports.md
│   └── migration-notes.md
└── DOCS_INDEX.md       # Master index linking to all documentation
```

### Documentation Rules:

1. **From Project Start:**
   - Create the `docs/` structure IMMEDIATELY when starting any project
   - Create subdirectories as needed based on project complexity
   - Never wait until documentation accumulates in root

2. **File Placement:**
   - Setup/installation docs → `docs/setup/`
   - Development workflows → `docs/development/`
   - Feature-specific docs → `docs/features/{category}/{subcategory}/`
   - General how-to guides → `docs/guides/`
   - API documentation → `docs/api/`
   - Status reports/changelogs → `docs/status/`
   - Agent/AI prompts → `docs/development/` or `docs/agent-guides/`

3. **Feature Hierarchy:**
   - Group related features by domain/module (authentication, data-processing, user-interface, etc.)
   - Create nested subdirectories for complex features with multiple components
   - Each feature category should have logical subcategories as needed
   - Example: `docs/features/data-processing/scraping/image-scraping.md`
   - Use overview.md at each level to explain the category/feature
   - Keep hierarchy shallow (max 3-4 levels deep) for easy navigation

4. **Naming Conventions:**
   - Use UPPER_CASE for major documents (QUICK_START.md, TESTING_STRATEGY.md)
   - Use kebab-case for feature-specific docs (image-scraping.md, oauth-setup.md)
   - Use descriptive names that indicate content and purpose
   - Use overview.md or index.md for category/directory introductions

5. **Documentation Index:**
   - Maintain `docs/DOCS_INDEX.md` with links to all documentation
   - Update index whenever new documentation is created
   - Categorize and describe each document's purpose
   - Organize index by feature hierarchy to match directory structure

6. **Root README.md:**
   - Keep concise (under 200 lines ideally)
   - Link to detailed docs in `docs/` directory
   - Include only: project overview, quick start, and navigation links

7. **When Creating Documentation:**
   - Ask yourself: "Does this belong in root?" (Answer is almost always NO)
   - Determine the appropriate feature category and subcategory
   - Create necessary subdirectory structure if it doesn't exist
   - Place it in the appropriate `docs/` subdirectory immediately
   - Update the documentation index with the new hierarchy

8. **Migration:**
   - If joining an existing project with docs in root, organize them into `docs/` structure
   - Analyze existing docs to determine feature categories
   - Create proper hierarchical subdirectories before moving files
   - Update any broken links in documentation after moving

### Anti-Patterns to AVOID:
- ❌ Creating COMPLETION_SUMMARY.md, STATUS_UPDATE.md, etc. in root
- ❌ Multiple README files (README2.md, README_OLD.md, etc.)
- ❌ Documentation files named with dates in root (REPORT_2024_10_14.md)
- ❌ Dumping all docs into `docs/` without subdirectories
- ❌ Dumping all feature docs into flat `docs/guides/` or `docs/features/` without categorization
- ❌ Creating temporary docs in root "just for now"
- ❌ Overly deep hierarchies (more than 6 levels) that make navigation difficult
- ❌ Inconsistent naming (mixing UPPER_CASE and kebab-case in the same directory)

## Proactive Innovation
- Suggest improvements, optimizations, and alternative approaches
- Recommend tools, libraries, or methodologies that could benefit the project
- Offer creative solutions even when not directly related to the current task
- Think beyond the immediate request to provide additional value

## Testing Requirements - MANDATORY

### CRITICAL: Every feature MUST have these tests BEFORE it's considered complete:

#### 1. Integration Tests (API + Component Data Flow)
- **MANDATORY for every API endpoint:**
  - Test the ACTUAL response structure (object vs array)
  - Validate ALL required fields are present
  - Verify data types match what components expect
  - Test that arrays are actually arrays, not objects
  - Validate nested data structures
  - Test with REAL data, not mocks
- **Why:** Prevents runtime errors from API/component data mismatches
- **Location:** `frontend/tests/integration/`

#### 2. End-to-End Tests (Full User Flow)
- **MANDATORY for every user-facing feature:**
  - Test complete user workflows from login to feature interaction
  - Monitor console for JavaScript runtime errors
  - Verify no "X is not a function" errors occur
  - Test with actual network requests (no mocks)
  - Validate data displays correctly in the UI
  - Test user interactions (clicks, inputs, forms)
- **Why:** Catches runtime errors that only appear with real data flow
- **Location:** `frontend/tests/e2e/`

#### 3. API Response Validation Tests
- **MANDATORY for ALL API routes:**
  - Every endpoint MUST have a test validating response structure
  - Test GET, POST, PUT, DELETE methods separately
  - Verify Content-Type headers
  - Test error responses (400, 401, 404, 500)
  - Validate pagination/filtering if applicable
- **Why:** Ensures API contract matches frontend expectations
- **Location:** `frontend/tests/integration/api-response-validation.test.ts`

#### 4. Component Integration Tests
- **MANDATORY when components fetch data:**
  - Test component with real API calls (not mocked)
  - Verify component handles loading states
  - Verify component handles error states
  - Verify component handles empty data
  - Test that filter/map/reduce operations work on actual data
- **Why:** Catches type mismatches and runtime method errors
- **Location:** `frontend/tests/integration/`

### Test Execution Protocol - NON-NEGOTIABLE:

1. **BEFORE marking any feature complete:**
   - Write integration tests for API endpoints
   - Write E2E tests for user flows
   - Run ALL tests and verify they PASS
   - Fix failures by addressing ROOT CAUSE, not workarounds

2. **AFTER implementing any feature:**
   - Run the specific test suite for that feature
   - Run full regression suite
   - Check browser console for errors during E2E tests
   - Verify no new linter errors

3. **Test Quality Standards:**
   - Tests MUST use REAL data, not mocks (except for external APIs)
   - Tests MUST verify actual data structures, not just success flags
   - Tests MUST catch runtime errors (TypeError, filter is not a function, etc.)
   - Tests MUST be specific enough to pinpoint the exact failure

4. **What Should Have Been Tested:**
   - **Example Bug:** `prosCons.filter is not a function`
   - **Missing Test:** Integration test validating API returns array, not object
   - **Missing Test:** E2E test that actually loads the component with real data
   - **Lesson:** Always validate data types match between API and component

### Test-Driven Development:

- Write tests FIRST when possible
- For bug fixes, write a test that reproduces the bug FIRST
- Test must FAIL initially, then PASS after fix
- All tests must continue to PASS after fix

### Regression Prevention:

- Every bug fix MUST include a test that would have caught it
- Run full test suite before committing
- CI/CD must run all tests
- Zero tolerance for skipped or disabled tests without documented reason

engineering-guardrails
  - Prefer clarity over cleverness; small, composable modules.
  - No shared mutable state across services; communicate over HTTP.
  - Strict typing with Pydantic models; validate inputs/outputs at service boundaries.
  - Fail fast at boundaries, return structured error payloads; never swallow exceptions.
  - Use correlation/request IDs across hops; propagate X-Request-ID.

General API Guidelines: 
  api-implementations:
    - Use FastAPI, httpx.AsyncClient with timeouts and retries.
    - Enforce JSON schemas for requests and responses.
    - Background work: FastAPI BackgroundTasks or simple queue later.

  api monitoring:
    - GET /health on every service (readiness/liveness).
    - Structured logs to stdout: JSON lines with request_id, latency_ms, status.

  api security:
    - API keys or JWT between core and plugins (env-configured).
    - Never log sensitive data; redact email, phone, api_key.
    - Secrets via env/SSM.

  python style:
    - Python 3.11+, ruff/black/isort; mypy strict for public modules.

  review-checklist:
    - Interfaces match schemas; errors structured; timeouts sane; logs structured; no secrets; tests present.

fastapi-guidelines:
  principles:
    - Write concise, technical code with accurate Python examples.
    - Prefer functional, declarative style; avoid classes when not needed.
    - Use descriptive variable names with auxiliary verbs (e.g., is_active, has_permission).
    - Use lowercase_with_underscores for files/dirs (e.g., routers/user_routes.py).
    - Use RORO (Receive an Object, Return an Object) pattern for function IO.
  python_fastapi:
    - Use def for pure CPU-bound functions, async def for I/O-bound operations.
    - Add type hints to all function signatures; validate with Pydantic v2 models.
    - Structure files: exported router, sub-routes, utilities, static content, types (models, schemas).
    - Prefer lifespan context managers over startup/shutdown events.
    - Use middleware for logging, error monitoring, performance.
    - Use HTTPException for expected errors; central middleware for unexpected errors.
    - Optimize with async operations for external calls and DB access.
  error_handling:
    - Handle edge cases first with guard clauses; return early.
    - Place the happy path last for readability; avoid deep nesting/else when possible.
    - Consistent structured error payloads: { code, message, details, request_id }.
  performance:
    - Avoid blocking I/O in routes; use async HTTP clients and DB drivers.
    - Cache static/frequently accessed data (in-memory/Redis) when needed.
    - Keep route handlers small; push heavy logic to services/utilities.

workspace-rules:
  - Task-Driven Development: do not change code without an approved, explicit task.
  - Use Cursor todo lists; seek approval of task list and approach before executing.
  - No changes outside current task scope.
  - Avoid writing docs unless instructed; if needed, get approval first.
  - No emoticons in documentation.

execution-sequence:
  - SEARCH FIRST: explore codebase/schemas to confirm prior art before implementing.
  - REUSE FIRST: extend existing functions/patterns; prefer smallest viable edits.
  - NO ASSUMPTIONS: rely only on code, schemas, and approved instructions; ask when missing.
  - CHALLENGE IDEAS: call out flaws/risks; propose better approaches directly.
  - BE HONEST: state blockers or gaps; do not overpromise.

coding-standards:
  - Plan before coding; explain reasoning for complex suggestions in PRs.
  - Write self-explanatory code; comments only for non-obvious rationale and invariants.
  - Keep imports alphabetically sorted.
  - Keep files under ~300 lines (where it makes sense) which is where code clarity improves; split when it helps.
  - Keep infra costs low; default to cost-effective choices. Cloudflare workers/pages are always preferred.
  - Use regression testing for all frontend functionality and tests leveraging playwright.
  - Test suites should be run locally and on CI.
  - Run linters/formatters (ruff/black/isort) and mypy strict for public modules.

github-rules:
  - Conventional Commits; PR template must answer schema/back-compat/timeouts/logging.
  - Ensure CI checks: unit, integration, schema validation.